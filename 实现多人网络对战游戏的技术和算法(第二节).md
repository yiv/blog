# 实现多人网络对战游戏的技术和算法(第二节)

* [Client-Server Game Architecture](https://github.com/yiv/blog/blob/master/实现多人网络对战游戏的技术和算法(第一节).md)
* [Client-Side Prediction and Server Reconciliation](https://github.com/yiv/blog/blob/master/实现多人网络对战游戏的技术和算法(第二节).md)
* [Entity Interpolation](https://github.com/yiv/blog/blob/master/实现多人网络对战游戏的技术和算法(第三节).md)
* [Lag Compensation](https://github.com/yiv/blog/blob/master/实现多人网络对战游戏的技术和算法(第四节).md)
* [Live Demo](http://www.gabrielgambetta.com/client-side-prediction-live-demo.html)

## Client-Side Prediction and Server Reconciliation

> 译自 [Fast-Paced Multiplayer](http://www.gabrielgambetta.com/client-server-game-architecture.html)

### 介绍
在这系列文章中的第一篇，我们探讨了基于权威服务器和哑客户端的客户端-服务器模型，客户端只负责向服务器发送玩家的输入然后将服务器返回的最新游戏状态显示在屏幕上。

基于这种模型的简单实现会导致玩家输入操作和屏幕变化之间产生延迟。比如玩家按下向右箭头键后，游戏角色要等半秒后才开始移动。这是因为客户端的输入首先要传输到服务器，服务器处理操作请求后计算出新的游戏状态，再把状态返回到客户端才算完成。

![](http://www.gabrielgambetta.com/img/fpm2-01.png)

在像因特网这样的网络中，网络延迟会达到数十秒，在好的情况下玩家会感觉到游戏反应迟钝，在坏的情况下基本丧失可玩性。在这篇文章中，我们会找到一种方法最小化甚至于消除这样的问题。

### 客户端预测

即使存在作弊玩家，但在大多数时候服务器都是在处理合法请求（来自于非作弊客户端的请求和来自作弊客户端的非作弊请求）。这就意味着接收到的大多数输入是合法的，而且会如预期的更新游戏状态。就是说，如果你的角色位置在 (10, 10) ，按下右方向键后，他会停留在 (11, 10)。

我们可以利用这点优势。如果游戏具有足够的确定性（就是说，基于一个游戏状态和一系列输入操作，得到的结果是可预期的）。

让我们假设有100ms的延迟，游戏角色移动一个单位的动画时长也是100ms。基于原生的实现，整个过程需要耗时200ms：

![](http://www.gabrielgambetta.com/img/fpm2-02.png)

既然游戏世界是可预期的，我们可以假设发送到服务器的输入操作会得到正确执行。基于这样的假设，客户端可以预知这次操作后的游戏状态，大多数时候都不会出错。

客户端发送输入请求后不用再等到服务器返回状态再渲染界面，取而代之的是发送输入请求后直接开始渲染界面，在我们等待服务器返回真正的游戏状态回来之前，就默认输入请求在发送那一刻就已经成功了一样 - 大多数时候服务器返回的状态和客户端本地都是吻合的：

![](http://www.gabrielgambetta.com/img/fpm2-03.png)

现在，在玩家操作和屏幕显示结果之间就没有延迟了，与此同时服务器仍然是唯一权威（如果一个作弊玩家发送非法的请求，他自己的屏幕会显示他所想看到的，但是并不能影响服务器的游戏状态，即不会影响到其它玩家）。

### 同步问题

在上面的例子中，我刻意地设置了数值，以便可以正常工作。然后，想想一个改版过的场景：我们假设到服务器有250ms的延迟，角色移动一个单位只耗时100ms。同时假设玩家连续按了两下向右方向键，想要向右移动两个单位。

使用目前我们想到的技术方案，会发生这样的情况：

![](http://www.gabrielgambetta.com/img/fpm2-04.png)

当服务器在t = 250ms时返回第一个状态，我们遇到了一个有趣的问题。客户端预测的当前位置是 x = 12，但是服务器返回来的新状态是 x = 11，因为服务器是权威，客户端必须把游戏角色移回到 x = 11，但是呢，紧接着服务器在t = 350m返回第二个状态 x = 12，于是角色再次跳回到 x = 12。

从玩家的角度来看，他按两次右方向键，角色向右移动两个单位，在那里停留了50ms，然后向左跳回去一个单位，停留100ms，再向右跳一个单位，当然，这是不可接受的。

### 服务器校对
解决这个问题的关键是要意识到，客户端看到的游戏世界是实时的，但由于延迟，从服务器收到的游戏状态更新都是“过去时”。服务器返回第一个状态时，它还没有处理完客户端所有的请求。

这个问题处理起来也不难。首先，客户端给每个请求附加一个序列号，在我们的例子中，第一次按键为请求#1，第二次按键为请求#2。然后，当服务器返回的时候，它将当次处理的请求序号包含到返回结果里：

![](http://www.gabrielgambetta.com/img/fpm2-05.png)

现在，当时间为 t = 250 时，客户端收到服务器的返回说“基于我收到你的请求#1，计算后你的新坐标是 x = 11”。因为服务器是权威，服务器将角色坐标设为 x = 11。现在我们假设客户端把发送给服务器的请求在本地存有个副本。基于从服务器收到的新状态，客户端知道服务器已经处理了请求#1，于是它就可以把这个副本删除了，同时客户端知道服务器还需要返回请求#2的结果。于是，客户端再次运行预测算法，客户端可以基于服务器最后一次返回给自己的状态，再加上服务器还没有返回处理结果的操作，从而计算出角色当前的“实时”状态。

所以，在 t = 250 时，客户端收到“x = 11, 本次处理请求序号 = #1”。客户端删除#1的请求副本 - 但它仍保留着还没有得到服务器确认的#2的请求副本。客户端使用服务器返回的 x = 11 更新自己的内部状态，同时在此基础上叠加处理仍没有被服务器确认的所有操作 - 这个例子中就是#2的请求“向右移一个单位”。计算的结果是 x = 12, 是正确的。

继续我们的例子，在t = 350时，从服务器收到新的状态，这次服务器说“x = 12， 本次处理请求序号 = #2”。到此为止，客户端删除所有小于等于#2的请求副本，用 x = 12更新状态。没有更多未处理的返回，所以本例处理结束，状态正确。

### 更多需要处理的问题

上面的例子主要讨论的是角色移动，但是同样的原理可以应用到游戏中几乎所有的情形。例如，在一个回合制的对战游戏中，当一个玩家攻击了另一个玩家，你可以在屏幕上通过血量或数量显示攻击遭成的损伤，但是在得到服务器的确认前，你不能真正地去更新玩家的状态。

由于游戏状态的复杂性，有的状态是不逆的，在得到服务器的确认前，你要避免在客户端界面上显示角色被杀死，即使这个角色的生命值已经降到0以下（比如万一那个角色使用了急求包，只是你还没有收到服务器的通知呢？）

这又给我们带出另一个有趣的问题 - 即使游戏世界具备完全的确定性，也没有任何玩家作弊，客户端预测的状态即使经过校对处理，仍存在与服务器状态不一致的可能性。这种情形在只有一个玩家的时候不可能发生，但在同时有多个玩家连接到服务器时却很容易发生，这就是我们下一篇文章讨论的主题。

### 总结

当使用权威服务器的时候，我们需要在客户端给玩家呈现及时响应的观感，而在后台却仍在等待服务器的确认。为达到这样的效果，客户端实时模拟玩家操作的结果。当服务器的状态返回时，通过收到的新状态和服务器仍没有确认的操作重新计算客户端的预测结果。


